/*
 * generated by Xtext
 */
package com.rockwellcollins.validation;

import static com.rockwellcollins.spear.utilities.Utilities.checkForObserveFlag;
import static com.rockwellcollins.spear.utilities.Utilities.checkForUFCFlag;

import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ComposedChecks;

import com.google.inject.Inject;
import com.rockwellcollins.spear.BinaryExpr;
import com.rockwellcollins.spear.Constant;
import com.rockwellcollins.spear.Constraint;
import com.rockwellcollins.spear.Definitions;
import com.rockwellcollins.spear.Expr;
import com.rockwellcollins.spear.File;
import com.rockwellcollins.spear.IdExpr;
import com.rockwellcollins.spear.Import;
import com.rockwellcollins.spear.NamedTypeDef;
import com.rockwellcollins.spear.PreviousExpr;
import com.rockwellcollins.spear.SpearPackage;
import com.rockwellcollins.spear.Specification;
import com.rockwellcollins.spear.UnaryExpr;
import com.rockwellcollins.spear.Variable;
import com.rockwellcollins.spear.typing.PrimitiveType;
import com.rockwellcollins.spear.typing.SpearTypeChecker;
import com.rockwellcollins.spear.typing.Type;
import com.rockwellcollins.spear.utilities.ConstantChecker;
import com.rockwellcollins.spear.utilities.Utilities;

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#
 * validation
 */

@ComposedChecks(validators = { NamesUnique.class, SpecificationValidator.class, VariablesAreUsedValidator.class,
		IllegalAnalysisValidations.class, DataValidator.class })

public class SpearJavaValidator extends com.rockwellcollins.validation.AbstractSpearJavaValidator {

	public static final String INVALID_ASSUMPTION_REF = "INVALID_ASSUMPTION_REF";

	@Check
	public void checkAssumptions(Specification s) {
		Set<String> valids = s.getInputs().stream().map(in -> in.getName()).collect(Collectors.toSet());
		Set<String> invalids = s.getOutputs().stream().map(out -> out.getName()).collect(Collectors.toSet());
		invalids.addAll(s.getState().stream().map(local -> local.getName()).collect(Collectors.toSet()));

		for (Constraint assumption : s.getAssumptions()) {
			for (IdExpr ide : EcoreUtil2.getAllContentsOfType(assumption, IdExpr.class)) {
				if (ide.getId() instanceof Variable) {
					Variable var = (Variable) ide.getId();
					if (invalids.contains(var.getName())) {
						warning("Assumption references computed (locals or outputs) variables.", ide,
								SpearPackage.Literals.ID_EXPR__ID, INVALID_ASSUMPTION_REF,
								valids.toArray(new String[valids.size()]));
					}
				}
			}
		}
	}

	public static final String MISMATCHED_FILENAME = "MISMATCHED_FILENAME";

	@Check
	public void checkSpecNameMatchesFilename(File f) {
		String filename = f.eResource().getURI().trimFileExtension().lastSegment();
		if (!filename.equals(f.getName())) {
			error("File ID name must be " + filename, f, SpearPackage.Literals.FILE__NAME, MISMATCHED_FILENAME,
					filename);
		}
	}

	@Check
	public void checkDefinitionsOnlyImportDefinitions(Definitions d) {
		for (Import im : d.getImports()) {
			File f = Utilities.getImportedFile(im);
			if (f instanceof Specification) {
				error("Definitions files cannot import Specifications.", im, SpearPackage.Literals.IMPORT__IMPORT_URI);
			}
		}
	}

	@Check
	public void checkConstantsAreConstant(Constant c) {
		if (!ConstantChecker.isConstant(c)) {
			error("Constant " + c.getName() + " is defined by a non-constant expression.", c.getExpr(), null);
		}
	}

	@Check
	public void checkInitialIsNotEmbedded(UnaryExpr ue) {
		if (ue.getOp().equals("initially")) {
			if (ue.eContainer() instanceof Expr) {
				error("The initially operator cannot be embedded within expressions.", ue, null);
			}
		}
	}

	@Check
	public void checkPreviousExpressionsAreGuarded(PreviousExpr pe) {
		EObject container = Utilities.getTopContainer(pe);
		if (!options.isUnusedValidationsDisabled() && container instanceof Specification && pe.getInit() == null) {
			warning("No initial value was specified. Analysis will consider all possible values for the initial state.",
					pe, null);
		}
	}

	@Check
	public void checkForIllegalSectionheaders(Specification s) {
		String requirements = s.getRequirementsKeyword();
		String behaviors = s.getBehaviorsKeyword();
		if (requirements.equals(behaviors)) {
			error("Duplicate section name used: " + requirements, s,
					SpearPackage.Literals.SPECIFICATION__REQUIREMENTS_KEYWORD);
			error("Duplicate section name used: " + requirements, s,
					SpearPackage.Literals.SPECIFICATION__BEHAVIORS_KEYWORD);
		}
	}

	@Check
	public void checkAliasTypeUnits(NamedTypeDef ntd) {
		if (ntd.getUnit() != null && !PrimitiveType.isPrimitive(ntd.getType())) {
			error("Unit definitions only allowed on primitive types.", ntd, SpearPackage.Literals.NAMED_TYPE_DEF__UNIT);
		}
	}

	@Check
	public void checkPropertiesOnlyHaveWitnessFlags(Specification s) {
		for(Constraint c : s.getAssumptions()) {
			if (checkForObserveFlag(c) || checkForUFCFlag(c)) {
				error("Flag is invalid for " + s.getAssumptionsKeyword() + ".",c,SpearPackage.Literals.FORMAL_CONSTRAINT__FLAG);
			}
		}
		
		for(Constraint c : s.getRequirements()) {
			if (checkForObserveFlag(c)) {
				error("Flag is invalid for " + s.getRequirementsKeyword() + ".",c,SpearPackage.Literals.FORMAL_CONSTRAINT__FLAG);
			}
		}
	}

	@Inject
	protected IValidatorAdvisor options;

	@Check
	public void checkNonlinearDivision(BinaryExpr be) {
		if (options.isSolverNonlinear()) {
			return;
		}

		boolean isLeftConstant = ConstantChecker.isConstant(be.getLeft());
		boolean isRightConstant = ConstantChecker.isConstant(be.getRight());

		switch (be.getOp()) {
		case "/":
		case "mod":
			if (!isRightConstant) {
				error("Division by non-constant expressions is not supported.", be,
						SpearPackage.Literals.BINARY_EXPR__RIGHT);
			}
			break;

		case "*":
			if (!isLeftConstant && !isRightConstant) {
				error("Multiplication by non-constant expressions is not supported.", be, null);
			}
			break;

		default:
			break;
		}
	}

	@Check
	public void checkNonlinearModulus(BinaryExpr be) {
		if (options.isSolverNonlinear()) {
			return;
		}

		Type leftType = SpearTypeChecker.typeCheck(be.getLeft());

		if (be.getOp().equals("mod") && leftType.equals(PrimitiveType.REAL)) {
			error("Real modulus is only supported on non-linear solvers.", be, null);
		}
	}
}
